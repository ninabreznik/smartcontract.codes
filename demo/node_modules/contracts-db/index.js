const hypercore = require('hypercore')
const hypertrie = require('hypertrie')
const ram = require('random-access-memory')
let samples = require('./samples')
const eos = require('end-of-stream')
const HyperswarmClient = require('hyperswarm-proxy-ws/client')
const swarm = new HyperswarmClient({ proxy: 'wss://188.166.164.180:3472' })

module.exports = contractsDB

function contractsDB (dat, pageSize) {
  let ids = 1
  const cancelled = {}
  let queue = []
  let isReady = false

  const key = Buffer.from(dat, "hex")
  const feed = new hypercore(ram, key)
  const trie = hypertrie(null, { feed })
  swarm.on('connection', (connection, info) => {
    console.log('connection found')
    connection.pipe(feed.replicate(info.client)).pipe(connection)
    eos(connection, function(err) {
      // this will be set to the stream instance
      if (err) return console.log('stream had an error or closed early', err);
      console.log('stream has ended', this === connection);
    });
    console.log('SWARM CONNECTIONS', swarm.connections)
  })
  swarm.join(key)

  isReallyReady()
  return { getStream, getBatch, search, cancel, getPagesCount, getSamples }

  function reallyReady (trie, cb) {
    if (trie.feed.peers.length) {
      trie.feed.update({ ifAvailable: true }, cb)
    } else {
      trie.feed.once('peer-add', () => {
        trie.feed.update({ ifAvailable: true }, cb)
      })
    }
  }

  function isReallyReady () {
    trie.ready(() => {
      console.log('Loaded trie', dat)
      reallyReady(trie, () => {
        console.log('READY')
        isReady = true
        var _queue = queue
        queue = []
        _queue.forEach(f => f())
      })
    })
  }

  async function getSamples (filter, cb) {
    let sampleContracts = {Basic: [], Audited: [], New: [], Featured: [], Popular: [], OpenZeppelin: []}
    const filterContracts = JSON.parse(samples)[filter]
    for(var i = 0; i < filterContracts.length; i++) {
      const name = filterContracts[i]
      const url = `${window.location.origin}/demo/node_modules/contracts-db/sampleContracts/${name}.sol`
      const file = await fetch(url)
      const code = await file.text()
      const jsonUrl = `${window.location.origin}/demo/node_modules/contracts-db/samples.json`
      const jsonFile = await fetch(jsonUrl)
      const jsonData = await jsonFile.text()
      sampleContracts[filter].push({
        source: code,
        title: name,
        hash: '0x0000000000000000000000',
        metadata: jsonData
      })
    }
    cb(null, sampleContracts)
  }

  function getStream (notify) {
    trie.ready(() => {
      console.log('Loaded trie', dat)
      reallyReady(trie, () => {
        console.log('READY')
        trie.createReadStream()
        .on('data', data => notify(data))
        .on('end', _ => notify('end'))
      })
    })
  }

  function getBatch (currentPage, cardsCount, done) {
    var contracts = []
    if (isReady) _getBatch()
    else queue.push(_getBatch)
    function _getBatch () {
      console.log('READY')
      const from = (currentPage-1)*cardsCount
      const to = currentPage*cardsCount
      const prefix = from.toString().padStart(10, '0').split(0, from.length)
      const readStream = trie.createReadStream()
      .on('data', res => {
        console.log(res.key)
        const data = JSON.parse(res.value.toString('utf8'))
        contracts.push({
          source: data.sourceCode,
          title: data.contractName,
          hash: data.address,
          metadata: data
        })
        if (contracts.length === to) {
          console.log(to)
          console.log(contracts.slice(from, to))
          done(null, contracts.slice(from, to))
          readStream.on('close', console.log('stream closed'))
        }
      })
      //swarm.leave(key)
    }
  }

  function search (query, notify) {
    const id = ids++
    trie.createReadStream()
    .on('data', res => {
      const data = JSON.parse(res.value.toString('utf8'))
      const temp = normalizeWS(data.sourceCode.toString('utf8'))
      const formattedQuery = normalizeWS(query)
      if (temp.includes(formattedQuery)) {
        if (!cancelled[id]) {
          notify({
            type: 'searchResult',
            id,
            body: data
          })
        }
      }
    })
    .on('end', _ => notify({
      type: 'searchResult',
      id,
      body: 'end'
    }))
    return id
  }

  function normalizeWS(s) {
    // searchInput.replace(/\n. |\r/g, "")
    s = s.match(/\S+/g);
    return s ? s.join(' ') : '';
  }

  function cancel (id) {
    cancelled[id] = true
  }

  function getPagesCount (done) {
    return done(null, Math.floor(trie.feed.length/pageSize))
  }

}
