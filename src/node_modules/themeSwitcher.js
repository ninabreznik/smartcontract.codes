const bel = require('bel')
const csjs = require('csjs-inject')
const unfocusElement = require('unfocusElement')
module.exports = themeSwitcher

function themeSwitcher (notify) {
  let colors = [
    {
      class: css.cubeDark,
      theme: 'dark',
      id: 'darkTheme',
      active: true
    },
    {
      class: css.cubeWhite,
      theme: 'white',
      id: 'lightTheme',
      active: false
    }
  ]
  var activeColor
  const currentTheme = colors.filter( color => color.active )
                             .map( color => bel`<span class="${css.colorplate} ${color.class}"></span>`)
  let themes = (colors) => bel`${colors.reverse().map( color => {
    var colorEl = bel`
      <span class="${css.colorplate} ${color.class} ${color.active ? css.current : ''}"
      data-theme=${color.theme}
      onclick=${ (e) => select(e, color)}></span>`
    if (color.active) activeColor = colorEl
    return colorEl
  })}`

  let cube = bel`<div class=${css.switch} onclick=${(e) => openTheme(e)}>${currentTheme}</div>`
  let themeSwitch = bel`<div class=${css.themeSwitch}>${themes(colors)}</div>`

  unfocusElement(x => x === actions, (hasFocus) => {
    //@TODO don't trigger when pagination buttons are clicked
    if (hasFocus) return
    if (!themeSwitch.classList.contains(css.open)) return
    themeSwitch.classList.add(css.close)
    themeSwitch.classList.remove(css.open)
  })

  var actions =  bel`
    <div class=${css.actions}>
      ${cube}
      ${themeSwitch}
    </div>
  `
  return actions

  function openTheme(e) {
    if (themeSwitch.classList.contains(css.open)) return
    themeSwitch.classList.add(css.open)
    themeSwitch.classList.remove(css.close)
  }

  function select(e, color) {
    let colorEl = e.target
    let classes = [...colorEl.classList]

    if (colorEl.classList.contains(css.current)) return
    colorEl.classList.add(css.current)
    activeColor.classList.remove(css.current)
    activeColor = colorEl

    cube.firstChild.setAttribute('class', classes.join(' '))

    notify({ type: 'theme', data: color.id })

  }
}

const css = csjs`
.actions {
  position: relative;
}
.switch {
}
.switch .colorplate {
  margin-top: 5px;
}
.themeSwitch {
  position: absolute;
  right: -8px;
  top: 0px;
  z-index: 3;
  display: grid;
  grid-template: 1fr / repeat(2, 1fr);
  grid-gap: 4px;
  padding: 4px 8px 4px 8px;
  border-radius: 30px;
  background-color: var(--themeSwitch-background);
  visibility: hidden;
}
.colorplate {
  display: inline-block;
  width: 20px;
  height: 20px;
  border: 1px solid #888;
  border-radius: 6px;
  cursor: pointer;
}
.colorplate:last-child {
  margin-left: 0;
}
.cubeWhite {
  background-color: #fff;
}
.cubeDark {
  background-color: #1D1D26;
}
.cubeBlue {
  background-color: #33ccff;
}
.cubeYellow {
  background-color: #ffcc00;
}
.current {
  border: 1px solid var(--switch-current-border-color);
}
.open {
  display: grid;
  visibility: visible;
  animation: on .25s ease-in forwards;
}
.close {
  animation: off .25s ease-out forwards
}
@keyframes on {
  0% {
    opacity: 0;
  }
  100% {
    opacity: 1;
  }
}
@keyframes off {
  0% {
    visibility: visible;
    opacity: 1;
  }
  100% {
    visibility: hidden;
    opacity: 0;
  }
}
`
